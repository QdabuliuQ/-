给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

```
输入: [2,2,1]
输出: 1

输入: [4,1,2,1,2]
输出: 4
```

思路：使用异或法`^`来进行运算；
异或法：例如：1 ^ 3，就会将两个数字转为二进制，1的二进制为 0001，3的二进制为 0011，每一位进行比较，如果相同则为 0，不同为 1；如果两个完全相同的数进行异或运算，那么结果必定为 0；

```
1 ^ 3   4 ^ 4
0001	0100
0011	0100
0010	0000
```

所以线性对数组进行遍历，数组元素每次都进行异或运算，重复元素会出现两个次，那么异或运算就肯定为0，所以最后结果肯定是 0 ^ 某一个数，这个数必定就是要查找的数

```js
function singleNumber(nums: number[]): number {
    let i: number = 0
    // 线性遍历
    for(i = 1; i < nums.length; i ++) {	
        // 将结果保存到数组第一位
        nums[0] ^= nums[i]
    }
    return nums[0]
};
```

