[剑指 Offer II 088. 爬楼梯的最少成本 - 力扣（LeetCode）](https://leetcode.cn/problems/GzCJIP/)

数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。

每当爬上一个阶梯都要花费对应的体力值，一旦支付了相应的体力值，就可以选择向上爬一个阶梯或者爬两个阶梯。

请找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。

```
输入：cost = [10, 15, 20]
输出：15
解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。

输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出：6
解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。
```

思路：使用**动态规划**的思想，创建`dp`数组，由于可以从`0 / 1`开始，则将`dp[0] / dp[1]`设置默认值为 0；从 2 开始遍历

* `dp[i]`就是到第`i`层所需要耗费的体力
* `dp[i-1]`就是到了第`i-1`层所需要耗费的体力，加上`cost[i-1]`对应那层所需要的体力，即到`dp[i]`所需要的体力
* 由于可以选择爬`1 / 2`层，那么取`dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]`的最小值

```js
function minCostClimbingStairs(cost: number[]): number {
    // 动态规划
    // 获取每一个阶梯所耗费的体力
    let n = cost.length
    // 创建dp数组
    let dp = new Array(n + 1)
    // 0 1 默认体力消耗为 0
    dp[0] = dp[1] = 0
    for(let i = 2; i <= n; i ++) {
        // 由于每次可以走 1步或者 2步
        // 所以取 前一步 和 前两步 取最小值
        // dp[i-1]表示到达i-1层的时候所需要的体力
        // 加上 cost[i-1] 表示到达dp[i] 所需要的体力
        // dp[i-2]表示到达i-2层的时候所需要的体力
        // 加上 cost[i-2] 表示到达dp[i] 所需要的体力
        dp[i] = Math.min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])
    }
    return dp[n]
};
```

