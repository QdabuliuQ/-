给定一个 n x n 的二进制矩阵 image ，先 水平 翻转图像，然后 反转 图像并返回 结果 。

水平翻转图片就是将图片的每一行都进行翻转，即逆序。

* 例如，水平翻转 [1,1,0] 的结果是 [0,1,1]。

反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。

* 例如，反转 [0,1,1] 的结果是 [1,0,0]。

```
输入：image = [[1,1,0],[1,0,1],[0,0,0]]
输出：[[1,0,0],[0,1,0],[1,1,1]]
解释：首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；
     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]
     
输入：image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
输出：[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
解释：首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；
     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
```

思路：使用`map`函数，该函数遍历后的结果是一个新的数组；进行`map`遍历的时候，创建左右指针`i / j`，`while`循环，如果左右指针的元素相等，那么先翻转再反转的结果是一样的【自己可以去举例论证】，则只需要左右元素相等，则`^ 1【^表示相同则为0，不同则为1】`，最后判断`i == j【该情况是当子数组是奇数个的时候，则将中间元素取反】`是否成立，成立将其取反即可

```js
function flipAndInvertImage(image: number[][]): number[][] {
  	// map遍历返回新数组
    return image.map(item => {
      	// i左指针  j右指针
        let i: number = 0, j: number = item.length - 1
        while(i < j) {
          	// 左右元素是否相同
            if(item[i] == item[j]) {
              	// 相同为 0，不同为 1
                item[i] ^= 1  // 取反
                item[j] ^= 1
            }
          	// 移动指针
            i ++
            j --
        }
      	// 子数组为奇数个
        if(i == j) {
          	// 中间元素取反
            item[Math.floor(item.length / 2)] ^= 1
        }
        return item
    })
};
```

