[91. 解码方法 - 力扣（Leetcode）](https://leetcode.cn/problems/decode-ways/description/)

一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：

```
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
```

要 **解码** 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，`"11106"` 可以映射为：

- `"AAJF"` ，将消息分组为 `(1 1 10 6)`
- `"KJF"` ，将消息分组为 `(11 10 6)`

注意，消息不能分组为 `(1 11 06)` ，因为 `"06"` 不能映射为 `"F"` ，这是由于 `"6"` 和 `"06"` 在映射中并不等价。

给你一个只含数字的 **非空** 字符串 `s` ，请计算并返回 **解码** 方法的 **总数** 。

题目数据保证答案肯定是一个 **32 位** 的整数。

```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

思路：动态规划；如果使用`dfs`回溯进行计算，会导致超时，所以使用动态规划，每次遍历`i`的时候，只需要关心`i-1 / i-2`的状态，如果只选择`i`一个字符，则判断`s[i]`是否在`1 ~ 9`的范围内，如果是，则从`dp[i-1`的状态转移；如果选择两个字符`s[i-1 ~ i]`，则判断是否在`10 ~ 26`的范围内，如果是，则从`dp[i-2]`的状态转移

```typescript
function numDecodings(s: string): number {
  let n: number = s.length
  s = " " + s  // 边界
  let dp: number[] = new Array(n+1).fill(0)
  dp[0] = 1  // 边界
  for(let i = 1; i <= n; i ++) {
    let a: number = parseInt(s[i]), b: number = parseInt(s[i-1]+s[i])
    // 只选取一个字符 判断是否符合范围 是则从dp[i-1]上一个状态转移
    if(a >= 1 && a <= 9) dp[i] = dp[i-1]
    // 选取两个字符 判断是否符合范围 是则从dp[i-2]状态转移
    if(b >= 10 && b <= 26) dp[i] += dp[i-2]
  }
  return dp[n]
}
```

