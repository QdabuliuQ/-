[983. 最低票价 - 力扣（Leetcode）](https://leetcode.cn/problems/minimum-cost-for-tickets/description/)

火车票有 **三种不同的销售方式** ：

- 一张 **为期一天** 的通行证售价为 `costs[0]` 美元；
- 一张 **为期七天** 的通行证售价为 `costs[1]` 美元；
- 一张 **为期三十天** 的通行证售价为 `costs[2]` 美元。

通行证允许数天无限制的旅行。 例如，如果我们在第 `2` 天获得一张 **为期 7 天** 的通行证，那么我们可以连着旅行 7 天：第 `2` 天、第 `3` 天、第 `4` 天、第 `5` 天、第 `6` 天、第 `7` 天和第 `8` 天。

```
输入：days = [1,4,6,7,8,20], costs = [2,7,15]
输出：11
解释： 
例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：
在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。
在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。
在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。
你总共花了 $11，并完成了你计划的每一天旅行。
```

思路：动态规划；创建`dp`数组，记录第`i`天时的花费；然后遍历天数，当当天需要外出，则买票，获取`(i-1) + cost[0] / (i-7) + cost[1] / (i-30) + cost[2]`的最小值，赋值给`dp[i]`；不需要外出则`dp[i]当天花费`等于前一天的花费

```js
function mincostTickets(days: number[], costs: number[]): number {
    // m保存最久天数 + 1
    let n = days.length, m = days[n - 1] + 1
    const [a, b, c] = costs
    // 创建dp数组
    let dp = new Array(m)
    // 第一个值初始化为 0
    dp[0] = 0
    // 将days放入set当中 方便获取
    let set = new Set(days)
    // 逐天遍历
    for(let i = 1; i <= m; i ++) {
        // 如果当天需要旅游  则买票
        if(set.has(i)) {
            // 每次获取 i-天数 得到之前的花费   都必须判断是否越界
            // 获取1天前的费用 + cost[0]
            // 获取7天前的费用 + cost[1]
            // 获取30天前的费用 + cost[2]
            // 获取最小值 保存到dp[i] 
            dp[i] = Math.min((dp[i-1] ?? 0)+a, (dp[i-7] ?? 0)+b, (dp[i-30] ?? 0)+c)
        } else {  // 如果当天不需要旅游
            dp[i] = dp[i - 1]  // 获取上一天的值
        }
    }
    return dp[m - 1]
};
```

