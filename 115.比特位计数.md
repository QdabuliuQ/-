[338. 比特位计数 - 力扣（LeetCode）](https://leetcode.cn/problems/counting-bits/)

给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

```
输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10

输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```

思路：利用奇偶性来计算，创建`bits`数组存放结果，第一个元素设置为0

* 如果`i`为奇数，5，那么5的二进制为`101`，4的二进制为`100`，5比4多一个1，所以就是：`bits[i-1]+1`
* 如果`i`为偶数，8，那么8的二进制为`1000`，`8/2=4`的二进制：`0100`，所以8和4的二进制1的个数是相同的

```js
function countBits(n: number): number[] {
    let bits: number[] = []
    bits[0] = 0  // 第一个默认为 0
    // 从1开始遍历
    for(let i = 1; i <= n; i ++) {
        // 如果i为奇数  那么就是bits[i-1]的1个数+1
        // 如果为偶数，那么就是bits[i/2]的1个数
        bits[i] = (i % 2 == 1 ? bits[i-1]+1 : bits[i / 2])
    }
    return bits
};
```

