# KMP算法

当在一个字符串中寻找是否存在模式串，可以通过暴力求解或者`KMP`算法进行匹配

暴力求解：

* 通过`i / j`两个变量分别指向字符串和模式串，当`i / j`两个字符相等的时候都进行移动，如果出现`i / j`不相同的时候，`j`修改为0，`i`返回初始位置 + 1，重新进行比较
* 这种求解方式的时间复杂度为`O(mn)`

`kmp`算法：

* 由于暴力求解方法中，两个字符不相等的时候，会直接回退到初始位置 + 1，这就是导致算法效率低的原因；`kmp`算法需要一个`next`数组，该数组会存放的是字符`0-n`之间所有字符的最长相等前后缀，当两个字符不匹配的时候，可以通过`next`数组进行退回

* 例如模式串：`aabaaf`，前缀就是一个字符串不包含第一个字符，只包含后面的元素；后缀就是一个字符串不包含最后一个字符，只包含前面的所有元素；

  * `a`：没有前缀和后缀，所以`next[0]`表示索引为0的字符`a`的最长相等前后缀为 0；
  * `aa`：前缀为`a`，后缀也是`a`；所以`next[1]`表示索引为`0-1`之间的字符的最长相等前后缀为 1
  * `aab`：前缀为`a`，后缀`b`；不相等，所以`next[2]`为 0
  * `aaba`：前后缀都为a；但只构成一个；所以`next[3]`为1
  * `aabaa`：前后缀都可以为`aa`，构成两个；所以`next[4]`为 2
  * `aabaaf`：前后缀不相同，`next[5]`为 0

  ```js
  function getNext(next, s) {
    // s = aabaaf
    // next[0]表示第一个字符 a，a没有前缀也没有后缀，所以必定为 0
    next[0] = 0  // 初始化next
    // i为后缀末尾  j为前缀末尾
    let i = 0, j = 0;  // 创建i和j下标
    // 遍历模式串
    for(i = 1; i < s.length; i ++) {
      // 如果 字符s[i] 和字符s[j] 不相等的时候，并且j不为初始索引
      // 则向前查找 是否存在s[i]一样的字符，找到相同前后缀
      while(j > 0 && s[i] != s[j]) {
        j = next[j - 1]  // 回退
      }
      // 如果s[i] 和 s[j]相等
      if(s[i] == s[j]) j ++
      next[i] = j
    }
  }
  ```

* 在计算完成`next`数组后，通过`next`数组，决定了字符比较出现冲突的时候，返回到哪一个索引位置

  ```js
  function kmp(str, pat) {
    let next = []
    getNext(next, pat);  // 获取next数组
    let i = 0, j = 0;
    while(i < str.length) {
      // 字符对应  两个指针同时移动
      if(str[i] == pat[j]) {
        i ++
        j ++
      } else if (j > 0) {  // 字符无法对应 并且j已经移动 通过next数组进行回退
        j = next[j-1]
      } else {  // 如果第一个字符就不匹配  移动i
        i ++
      }
      // j移动到了模式串最后  表示匹配到了
      if(j == pat.length) return i - j
    }
    return -1
  }
  ```

  